# 键值数据库

## 暴力做法

用一个 $500000$ 的数组作为表，查找、添加、删除键值对都是 $O(1)$.

弹出具有最大价值的所有键，遍历一次数据表，找出最大值，再升序遍历一次，删除对应键，将对应键存储到另一个数组中，最后输出。时间复杂度 $O(M)$，其中 $M = 500000$.

查询中位数键对应的值，同样遍历一次数据表，存储所有有效键，直接找到中位数键，并输出对应值，时间复杂度 $O(M)$.

总体时间复杂度 $O(qM)$

优化1：用 `vector<int>`　存储所有有效键，查询中位数键前先排序一遍，时间复杂度降为 $O(q(n+q)log(n+q))$。

优化2：用 `vector<int>`　存储所有有效键，插入时用二分查找保证有序性，时间复杂度降为 $O(q(n+q))$.

## 正解

对于第一种操作，至少需要一个 `map<key, value>` 来存储。

对于第二种操作，需要有序反向映射，即 `map<value, set<key>>`。

对于第三种操作，容易想到对顶堆，然而 `priority_queue` 不支持删除，可删堆又不支持查找，什么结构可用呢？

`set<key>`: 那当然是……

`map<key, value>`: 当然是我了

```c++
map<int, set<int>, greater<int>> vk_map;
map<int, int> heap[2];
```

用两个 `map<key, value>` 模拟对顶堆，同步维护反向映射。

第一种操作：若没有 key，直接加入对顶堆，同步更新反向映射，若有，先删除原键值对，再加入新键值对。复杂度 `O(log(len))`，其中 $len$ 为数据库中键的个数。

第二种操作：取反向映射中的第一个，即最大值，输出集合中所有 键，同步从对顶堆中删除键，然后从反向映射中删除最大值。最坏情况：一次删除所有键，复杂度 `O(len*log(len))`，由于所有删除的键的数量不会超过 `n + q`，所以整体复杂度 `O((n+q)log(n+q))`。

第三种操作：从对顶堆中查找中位数键，输出对应值。复杂度 `O(log(len))`。

最终整体复杂度 `O((n+q)log(n+q))`。