## H - 假·签到题
判断一个数字有几个因子可以在 $O(n)$ 时间内处理，即穷举 $i=1...n$ ,判断 $i$ 是否为 $n$ 的因子。这样可以用两重循环把结果统计出来。最终复杂度 $O(n^2)$ 。

```cpp
#include <iostream>
using namespace std;
int main(){
    int t;
    cin>>t;
    while(t--){
        int n;
        cin>>n;
        int ans=0;
        for(int i=1;i<=n;i++){
            int cnt=0;
            for(int j=1;j<=i;j++){
                if(i%j==0){
                    cnt++;
                }  
            }
            if(cnt==4){
                ans++;
            } 
        }
        cout<<ans<<endl;
    }
    return 0;
}
```

## G - 真·签到题
这个题目和上一个题目唯一的区别是数据范围扩充到了 $10^9$ , 如果还是用 $O(n^2)$ 的算法大概要算 $10^10$ 秒，也就是317年左右......

所有我们要想办法降低时间复杂度。考虑任何一个 $4$ 因子数，只有两种情况，一种是立方数，一种是有且仅有两个素因子。立方数很好处理，数量就是三次根号 $n$ 。 接下来我们要找出 $[1,n]$ 内所有有且仅有两个素因子的数的个数。 对于任意一个满足条件的数字，我们不妨记为 $a$ ，满足：

$$a = p\times\ q$$

其中 $p,q$ 均为素数。由 $p\ !=\ q$ ，不妨设 $p<q$ ，对于任意确定的 $p$ , 我们要统计所有的 $a$ 满足 $a\leq n$。即 $q \leq floor(\frac{n}{p})$ , 则 $q$ 满足:

$$p<q\leq  floor(\frac{n}{p})$$

$q$的个数即为区间内素数的个数。我们考虑所有的素数 $p$ 满足 $p\in [2,sqrt(n)]$ , 求解对应 $q$ 的个数即可。我们预处理 $f(n)$ 表示小于等于 $n$ 的素数的个数，从而可以在 $O(sqrt(n))$ 的时间复杂度里解决问题。

接下来我们要处理的问题，就是低于线性时间的将 $f(n)$ 求出来。线性时间的话线性筛一下就做出来了。但是线性时间还不够快，要低于线性时间，我们引入一个算法洲阁筛，可以在 $O(\frac{n^\frac{3}{4}}{\ln n})$ 时间里预处理出来。考虑到大部分同学没有数论方面的基础，可以查看如下链接 https://blog.csdn.net/semiwaker/article/details/73822107

一般来说该算法处理问题的上限在 $10^{11}$ 左右，但是为了防止被看出是模板题并且简化题目，所有题目里用了 $10^9$。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
using namespace std;
typedef long long ll;
const int maxn = 1e6 + 5;
const ll maxm = 1e11;
const ll maxp = sqrt(maxm) + 10;
ll f[maxp],g[maxp];
bool isprime[maxn];
int prime[maxn];
int tot = 0;
void init()
{
    for(int i = 2; i < maxn; i ++) isprime[i] = true;
    for(int i = 2; i < maxn; i++){
        if(isprime[i]) prime[tot++] = i;
        for(int j = 0; j < tot && i * prime[j] < maxn; j++){
            isprime[i * prime[j]] = false;
            if(i % prime[j] == 0) break;
        }
    }    
}
ll solve(ll n)
{
    ll i,j,m;
    for(m = 1; m * m <= n; m++) f[m] = n/m - 1;
    for(i = 1;i <= m; i++) g[i] = i-1;
    for(i = 2; i <= m; i++){
        if(g[i] == g[i-1]) continue;
        for(j = 1; j <= min(m - 1, n/i/i); j++){
            if(i * j < m) f[j] -= f[i * j] - g[i - 1];
            else f[j] -= g[n/i/j] - g[i-1];
        }
        for(j = m;j >= i * i; j--) g[j] -= g[j / i] - g[i - 1];
    }
    ll ans = 0;
    for(int i = 2; i < m; i++){
        if(g[i] == g[i - 1]) continue;
        ans += f[i] - g[i];
    }
    return ans;
}
int main (void)
{
    int t;
    cin>>t;
    init();
    while(t--){      
        ll n;scanf("%lld", &n);
        ll ans = 0;
        for(int i = 0; i < tot; i++){
            if(prime[i] * 1LL * prime[i] * prime[i] > n) break;
            ans++;
        }
        printf("%lld\n", ans + solve(n));
    }
    return 0;
}
```
