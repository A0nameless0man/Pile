## I-格雷亲真可爱

首先，标题很正确，很给力，但是和题目内容没关系。 
这道题是一个披着外衣的 01 背包问题（动态规划）。（ACM中会有很多题目穿着各种奇怪的外衣，比如晕头的蚂蚁。）这道题目的难点显然在于，选的顺序不同，那么产生的影响也会不同（比如样例），因此对暴力算法造成了难度，思考起来也颇为复杂。但是，不管顺序怎么变，选定的宝石固定了，有一点是不变的，那就是会消耗多少宝石。
下面进入正文，拨开这个动态规划题的外衣。
先说结论：只要我们选取的 $k$ 个宝石所消耗的$k+\sum B_i$颗宝石（本身和后面的宝石），不超过总数 $n$ ，那么一定可以找到一种方法来进行魔术。
利用这个结论，我们令$W_i=B_i+1$（物品重量），$V_i=A_i$（物品价值），就变成了一个 $n$ 个物品 $n$ 承重的 01 背包问题。（没学过动态规划和 01 背包的需要先进行学习）有了结论，学过 01 背包的谁都会做，那么怎么得到这个结论呢？

证明如下：
利用反证法：
首先我们假设不能找到一个宝石，使得利用它发动魔术的时候不会让其他被选中的宝石消失。
那么对任意一个被选中的宝石 $x$，找它后面的离它最近的另一个被选中的宝石y（可以为 $x$ 本身，当只选一个宝石的时候），
$if（y>x) D=y-x;else D=n+x-y;$( $D$ 表示 $x$ 到 $y$ 相距多少个宝石）
有式一:$D_x<B_x+1$;
对选中的 $k$ 个宝石，共有 $k$ 对这样的相邻的被选中的宝石（若 $k$ 为 $1$，则有其本身构成的一对宝石），能写出 $k$ 个式一，对写出的 $k$ 个式一，小于号左右两边分别累加，
$\sum D_x<\sum (b_x+1)$,化简得，$n<k+\sum b_i$,与条件矛盾。
所以，一定可以找到一个被选中的宝石，使得利用它发动魔术的时候不会让其他被选中的宝石消失。
之后，也一定可以找到第二个被选中的宝石，以此类推，最终可以实现。
笔者出题的本心是希望大家看到题目能多多思考，考察研究模型。不要直接考虑xxx能不能用。
以上。
最后，格蕾亲真可爱，格蕾亲真可爱，格蕾亲真可爱。嘿嘿嘿。
```cpp
#include<iostream>
#include<stdio.h>
using namespace std;
long long  w[1005],v[1005];
long long dp[1005][1005];
int main(){
    long long i,j,n;
    scanf("%lld",&n);
    for(i=1;i<=n;i++)
    {
        scanf("%lld%lld",&v[i],&w[i]);
        w[i]++;
    }
    for(i=1;i<=n;i++)
    {
        for(j=n;j>=0;j--)
        {
            if(j>=w[i])
            {
                dp[i][j]=max(dp[i-1][j-w[i]]+v[i],dp[i-1][j]);
            }
            else dp[i][j]=dp[i-1][j];
        }
    }
    printf("%lld\n",dp[n][n]);
    return 0;
}
```
