---
author: "胡广"
date: 2020-03-04
title: "Storage of number"
---

众所周知，计算机采用二进制来存储信息，本文是我对于`计算机如何进行数字的存储与运算`这一主题的理解与思考。

[toc]

## Integer

二进制表示，如 `0b1100` 表示 `10`。

正数不是什么大问题，关键在负数。

### Negative integer with flag

最自然的想法是搞一个标识符，表明这是负数，比如对于单字节整型，`0b10000000`就是$-0$。虽然看上去不太合理，但也还好。  
但是当考虑数字的运算时就会发现这带来了不少麻烦。尤其是$-0$的存在，使得数字相等的判断不能采用内存逐位比较进行。
另外，这样的做法还使得大小顺序颠倒。对于无符号整型有$0b10000001 > 0b10000000$，但对于有符号整型，负数的大小完全颠倒了过来，也增加了程序的复杂度。

### Negative integer with mod

为了维护正常的大小顺序，考虑采用$\mod 2^{n}$意义下的负数。

比如说，

$$-1 \mod 2^8 = 2^8 -1 = 0b11111111$$

这正好是最大的负数

然后发现，由于模的性质满足
$$
\begin{align}
& (x+y)\mod 2^n \\
= & (x\mod 2^n + y\mod 2^n)\mod 2^n
\end{align}
$$
因此，正数与负数之间的加法就不需要构造一种独立的加法器了。

进一步的，其实也没有必要为减法构造减法器，毕竟减一个数相当于加上它的负数。

这种东西被称作补码(***Complement***)

### Complement calculator

下一步，考虑如何构造正负数转换的电路。或者说，构造一个函数使得

$$\forall x \in [0,2^{n-1}],f(x)=2^n-x$$

很明显，这里的减法不能直接实现。一方面，减法依赖于这个函数本身；另一方面$2^n$是超过$n$位计算机的表示能力的，或者说$2^n \equiv 0 \mod 2^n$。

不过我们知道，$2^n =(2^n-1)+1$,而$(2^n-1)-x$正是二进制取反的操作。因此可以定义这个函数为

$$\forall x \in [0,2^{n-1}],f(x)=\overline{x}+1$$

真是优雅

## Float
