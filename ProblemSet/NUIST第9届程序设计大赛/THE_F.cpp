#include <stdio.h>
/*
F :更厉害的数列（1）
时间限制:  1000MS   空间限制:  32MB   提交数:  28   通过数:  21
题目内容

题目描述

我们知道，假设有一个正整数x，如果我们想要求出x^11（即x的11次方）的值，最容易想到的办法就是循环相乘，于是我们很容易就可以写出来下面的伪代码：
1 → RES

FOR i FROM 1 TO 11

    RES * x → RES

PRINT RES
这种方法的时间复杂度是O(n)。但是，当n非常大的时候呢？假如n是10000，我们需要循环10000次吗？显然，我们有更好的办法。

我们还是来计算x的11次方。我们将11用2的指数形式加权来表示，那么11 = 23×1 + 22×0 + 21×1 +
2?×1。你可能已经发现了，2的指数的权值连起来就是11的二进制表示：1011。这样，我们要计算的x^11就可以转化为x^(2?)
× x^(21) × x^(23)，原来要乘11次的方法被我们缩减到了3次。

但是，x^(2?), x^(21), x^(23)又怎么能快速地算出呢？观察下面的程序：
/** 计算x^n的值 **

int res = 1;

while(n) {

    if (n & 1) {

        res *= x;

    }

    x *= x;

    n >>= 1;

}
位运算是计算机中非常强大的工具，x *= x一句就能在循环中不断地计算出x^(2?), x^(21), x^(22), ... 在n &
1的判断处，如果n的二进制末位是1，那res *= x就会被执行，x^(2^y)
（y为这个循环执行的次数）就会被乘进结果里，x^n就会被很快计算出来。这个算法的时间复杂度是O(log(n))。这种算法也被称作快速幂。

快速幂算法不仅仅可以用于快速地计算一个数的幂，也可以用于快速地计算矩阵的幂。先看下面的两个定义（如果你知道什么是矩阵、矩阵乘法，那可以跳过）：

矩阵的定义：
更厉害的数列1矩阵的定义

矩阵乘法的定义：
更厉害的数列1矩阵乘法的定义

当我们要计算一个矩阵A的幂时，也可以用快速幂算法，只需要把上方计算x^n的值的代码中res *= x和x *=
x两句替换成矩阵的乘法即可。

矩阵快速幂的用处很广泛，其中一项就是求斐波那契数列的第n项值。众所周知，斐波那契数列的递推公式为：f(n)
= f(n-1) + f(n-2)。因此，它也可以用矩阵表示。 图片描述

现在，设斐波那契数列的函数为f(n)，f(0)=0，f(1)=1，你能算出f(n)是多少吗？
输入描述

题目包含多组测试数据。第一行包括一个正整数T，代表测试数据的组数。

接下来的输入，每组输入包含一行，每一行有一个正整数n（0 < n <= 1,000,000,000）。
输出描述

对于每组测试数据，输出f(n)的最后四位数。如果f(n)的最后四位数都是0，输出0；否则，忽略所有先导0。（即：输出f(n)对10000取模）
样例输入

3

9

999999999

1000000000
样例输出

34

626

6875
*/
class M
{

public:
    M(void)
    {
        for(int i = 0; i < 2; i++)
            for(int j = 0; j < 2; j++)
                d[i][j] = 0;
    }
    int d[2][2];
    M   operator*(M b)
    {
        M r;
        for(int i = 0; i < 2; i++)
            for(int j = 0; j < 2; j++)
                r.d[i][j] = (this->d[i][0] * b.d[0][j] + this->d[i][1] * b.d[1][j]) % 10000;
        return r;
    }
};
int main(void)
{
    long n;
    scanf("%*d");
    while(scanf("%ld", &n) != EOF)
    {
        switch(n)
        {
            case 0:
                printf("0");
                break;
            case 1:
                printf("1");
                break;
            default:
                n--;
                M x;
                x.d[0][0] = 1;
                x.d[0][1] = 1;
                x.d[1][0] = 1;
                M res;
                res.d[0][0] = 1;
                res.d[1][1] = 1;
                res.d[0][1] = 0;
                res.d[1][0] = 0;
                while(n)
                {
                    if(n & 1)
                    {
                        res = res * x;
                    }
                    x = x * x;
                    n >>= 1;
                }
                printf("%d\n", (res.d[0][0]) % 10000);
        }
    }

    return 0;
}
